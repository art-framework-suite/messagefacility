#ifndef ERROROBJ_ICC
#error ErrorObj.icc erroneously included by file other than ErrorObj.h
#endif

#include <sstream>

namespace mf {

  // ----------------------------------------------------------------------
  // Methods for physicists adding to an ErrorObj:
  // ----------------------------------------------------------------------

  template <class T>
  std::enable_if_t<!detail::is_string_literal<T>::value, ErrorObj&>
  ErrorObj::opltlt (T const& t)
  {
    myOs.str({});
    myOs << t;
    if (!myOs.str().empty()) eo_emit(myOs.str());
    return *this;
  }

  inline ErrorObj&
  ErrorObj::opltlt (std::string const& s)
  {
    // Exactly equivalent to the general template.  If this is not
    // provided explicitly, then the template will be instantiated
    // once for each length of string ever used.
    myOs.str({});
    myOs << s;
    if (!myOs.str().empty() ) eo_emit( myOs.str() );
    return *this;
  }

  // ----------------------------------------------------------------------
  // Global method for physicists adding to an ErrorObj:
  // ----------------------------------------------------------------------


  template <class T>
  std::enable_if_t<!detail::is_string_literal<T>::value, ErrorObj&>
  operator<<(ErrorObj& e, T const& t)
  {
    return e.opltlt(t);
  }

  inline
  ErrorObj&
  ErrorObj::operator<<(std::ostream&(*f)(std::ostream&))
  {
    f(myOs);
    myOs.str({});
    return *this;
  }

  inline
  ErrorObj &
  ErrorObj::operator<<(std::ios_base&(*f)(std::ios_base&))
  {
    f(myOs);
    return *this;
  }

} // end of namespace mf

// Local variables:
// mode: c++
// End:
